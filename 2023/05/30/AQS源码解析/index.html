

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/avatar.jpeg">
  <link rel="icon" href="/img/avatar.jpeg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Handsome Young">
  <meta name="keywords" content="">
  
    <meta name="description" content="AQS源码解析    本文基于JDK19的源码     下面是源码里面注释的翻译，可以作为参考（代码头的注释实在翻译不过来了）  等待队列是“CLH”(Craig、Landin和Hagersten)锁队列的变体。CLH锁通常用于旋转锁。相反，我们通过包含显式(“prev”和“next”)链接和一个“status”字段来使用它们阻塞同步器，该字段允许节点在释放锁时通知后继者，并处理由于中断和超时而导">
<meta property="og:type" content="article">
<meta property="og:title" content="AQS源码解析.md">
<meta property="og:url" content="https://xiaohuanxiong3.github.io/2023/05/30/AQS%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/index.html">
<meta property="og:site_name" content="小浣熊的个人博客">
<meta property="og:description" content="AQS源码解析    本文基于JDK19的源码     下面是源码里面注释的翻译，可以作为参考（代码头的注释实在翻译不过来了）  等待队列是“CLH”(Craig、Landin和Hagersten)锁队列的变体。CLH锁通常用于旋转锁。相反，我们通过包含显式(“prev”和“next”)链接和一个“status”字段来使用它们阻塞同步器，该字段允许节点在释放锁时通知后继者，并处理由于中断和超时而导">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-05-30T09:41:55.000Z">
<meta property="article:modified_time" content="2023-06-03T10:34:43.217Z">
<meta property="article:author" content="Handsome Young">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>AQS源码解析.md - 小浣熊的个人博客</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_lbnruvf0jn.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"xiaohuanxiong3.github.io","root":"/","version":"1.9.2","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>小浣熊</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/poem/">
                <i class="iconfont icon-user-fill"></i>
                古诗词
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/thinking/">
                <i class="iconfont icon-user-fill"></i>
                思考ing
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="AQS源码解析.md"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-05-30 17:41" pubdate>
          2023年5月30日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          30k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          252 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">AQS源码解析.md</h1>
            
            
              <div class="markdown-body">
                
                <h3 id="AQS源码解析"><a href="#AQS源码解析" class="headerlink" title="AQS源码解析"></a>AQS源码解析</h3><p>    本文基于JDK19的源码</p>
<p>    下面是源码里面注释的翻译，可以作为参考（代码头的注释实在翻译不过来了）</p>
<blockquote>
<p>等待队列是“CLH”(Craig、Landin和Hagersten)锁队列的变体。<br>CLH锁通常用于旋转锁。相反，我们通过包含显式(“prev”和“next”)链接和一个“status”字段来使用它们阻塞同步器，该字段允许节点在释放锁时通知后继者，并处理由于中断和超时而导致的取消。<br>状态字段包括跟踪线程是否需要唤醒(使用LockSupport.unpark)的位。<br>尽管增加了这些，我们仍然保留了大部分CLH自己的属性。</p>
<p>要排队进入CLH锁的话，您需要使用原子操作将新节点拼接成新的队尾（tail），</p>
<p>要出队的话，您需要设置队头（head）字段，这样下一个符合条件的等待着就会变成第一个</p>
<p>+——–+  prev +———+         +——–+  </p>
<p>| head | &lt;—-  | first | &lt;—-   | tail |  </p>
<p>+——–+           +———+         +——–+</p>
<p>插入到CLH队列只需要在“tail”上执行一个原子操作，所以从非排队到排队有一个简单的分界点。前置节点的“nexi”链接由成功CAS后的排队线程设置。尽管是非原子的，这也足以保证任何阻塞的线程会在符合条件时由前驱节点唤醒。唤醒部分基于类似Dekker的方案，在该方案中要等待的线程指明等待状态（WAITIING status），然后重试获取，然后在阻塞之前重新检查状态。signaller在unpark时会自动清除WAITING状态</p>
<p>acquire时出队包含分离（清空）一个节点的“prev”节点然后更新“head”。其他线程通过检查“prev”而不是“head”来判断节点正在或者已经出队。如果有必要的话，我们通过旋转等待来强制取消然后设置顺序。因此，锁算法本身并不是严格意义上的“无锁”,因为获取线程可能需要等待前一次获取才能取得进展。当使用排他锁时，无论如何都需要这样的progess。然而，共享模式可能（罕见地）需要在设置head字段之前进行旋转等待，以确保正确传播。（与历史有关地注释：与该类之前的版本相比，这给到了简化和效率的提升）</p>
<p>节点的前驱能在等待时因为取消等待而改变，直到该节点称为队列中的第一个节点，这时节点就不能改变了。acquire method通过在等待前重新检查“prev”来处理这个问题。prev和next字段只能由方法 cleanQueue 中已取消的节点通过CAS进行修改。unsplice策略让人想起Michael-Scott队列，其在成功对prev字段成功进行CAS操作后，其他线程帮组修复next字段。因为取消经常成批发生，这使得关于必要唤醒的决策更加复杂，每次调用cleanQueue方法都会遍历队列直到彻底清除队列。首先被重新链接的节点会被无条件unpark（有时不是必要的，但是那些情况不值得避免）</p>
<p>如果线程是队列中的第一个(最前面的),有时是在前面，那么它可能会尝试acquire。成为第一个并不保证成功，它只是赋予了争取成功的权力。我们通过允许传入线程在入队过程中“闯入”并获取同步器来平衡吞吐量、开销和公平性，在这种情况下，被唤醒的第一个线程可能需要重新等待。为了抵消可能重复的不幸的重新等待，我们指数级地增加重试次数(高达256次),以在每次线程被解除锁定时获取。除了在这种情况下，AQS锁才&#x3D;不会旋转；相反，他们尝试去acquire与登记步骤交错进行（需要自旋锁的用户可以使用tryAcquire）</p>
<p>为了提高垃圾可回收性，还不在列表上的节点的字段为null（创建一个节点，不适用就扔掉它，这种情况并不罕见）。脱离list的节点字段会尽快清空。这突出了从外部确定第一个等待线程的挑战（就像在方法 getFirstQueuedThread 中一样）。当字段显示为null时，有时需要从原子更新的“tail”向后遍历的回退（这在唤醒过程（signalling）中是不需要的）</p>
<p>CLH队列需要一个伪头节点来开始。但是我们不会在构建的时候创建它们，因为如果没有contention，这将是白费力气。相反，在第一次contention的时候，我们才构建节点并设置头指针和尾指针。</p>
<p>共享模式操作不同于独占模式操作，因为如果它也是共享的，则获取操作会向下一个等待者发出尝试获取的信号。tryAcquireShared API允许用户指出传播的程度，但在大多数应用程序中，忽略这一点更有效，允许后继者在任何情况下尝试获取。</p>
<p>在Conditions中等待的线程使用带有附加链接的节点来维护condition的(FIFO)列表。Conditions只需要链接简单(非并发)链式队列中的节点，因为它们只在独占时被访问。在await时，一个节点被插入到条件队列中。一旦收到信号，该节点就在主队列中排队。一个特殊的状态字段值被用来跟踪和自动触发这种情况。</p>
<p>对字段head、tail和state的访问使用完全volatile模式以及CAS。节点字段status、prev和next也这样做，而线程可能是可发信号的，但除此之外有时使用较弱的模式。对字段“waiter”(要被唤醒的线程)的访问总是夹在其他原子访问之间，因此在普通模式下使用。我们使用jdk.internal不安全版本的原子访问方法而不是VarHandles来避免潜在的虚拟机引导问题。</p>
<p>以上大部分是由主要的内部方法acquire执行的，所有暴露的acquire方法都会以某种方式调用它（当大量使用时，编译器通常很容易专门为调用点优化。）在阻塞前和&#x2F;或阻塞后的获取和等待中，有几个关于何时以及如何检查中断的随意的决定。在实现的更新中，决策更加不随意因为一些用户似乎以一种racy的方式依赖于原始行为，一般来说，这很少是错误的，但是很难证明改变是合理的。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br><span class="line">656</span><br><span class="line">657</span><br><span class="line">658</span><br><span class="line">659</span><br><span class="line">660</span><br><span class="line">661</span><br><span class="line">662</span><br><span class="line">663</span><br><span class="line">664</span><br><span class="line">665</span><br><span class="line">666</span><br><span class="line">667</span><br><span class="line">668</span><br><span class="line">669</span><br><span class="line">670</span><br><span class="line">671</span><br><span class="line">672</span><br><span class="line">673</span><br><span class="line">674</span><br><span class="line">675</span><br><span class="line">676</span><br><span class="line">677</span><br><span class="line">678</span><br><span class="line">679</span><br><span class="line">680</span><br><span class="line">681</span><br><span class="line">682</span><br><span class="line">683</span><br><span class="line">684</span><br><span class="line">685</span><br><span class="line">686</span><br><span class="line">687</span><br><span class="line">688</span><br><span class="line">689</span><br><span class="line">690</span><br><span class="line">691</span><br><span class="line">692</span><br><span class="line">693</span><br><span class="line">694</span><br><span class="line">695</span><br><span class="line">696</span><br><span class="line">697</span><br><span class="line">698</span><br><span class="line">699</span><br><span class="line">700</span><br><span class="line">701</span><br><span class="line">702</span><br><span class="line">703</span><br><span class="line">704</span><br><span class="line">705</span><br><span class="line">706</span><br><span class="line">707</span><br><span class="line">708</span><br><span class="line">709</span><br><span class="line">710</span><br><span class="line">711</span><br><span class="line">712</span><br><span class="line">713</span><br><span class="line">714</span><br><span class="line">715</span><br><span class="line">716</span><br><span class="line">717</span><br><span class="line">718</span><br><span class="line">719</span><br><span class="line">720</span><br><span class="line">721</span><br><span class="line">722</span><br><span class="line">723</span><br><span class="line">724</span><br><span class="line">725</span><br><span class="line">726</span><br><span class="line">727</span><br><span class="line">728</span><br><span class="line">729</span><br><span class="line">730</span><br><span class="line">731</span><br><span class="line">732</span><br><span class="line">733</span><br><span class="line">734</span><br><span class="line">735</span><br><span class="line">736</span><br><span class="line">737</span><br><span class="line">738</span><br><span class="line">739</span><br><span class="line">740</span><br><span class="line">741</span><br><span class="line">742</span><br><span class="line">743</span><br><span class="line">744</span><br><span class="line">745</span><br><span class="line">746</span><br><span class="line">747</span><br><span class="line">748</span><br><span class="line">749</span><br><span class="line">750</span><br><span class="line">751</span><br><span class="line">752</span><br><span class="line">753</span><br><span class="line">754</span><br><span class="line">755</span><br><span class="line">756</span><br><span class="line">757</span><br><span class="line">758</span><br><span class="line">759</span><br><span class="line">760</span><br><span class="line">761</span><br><span class="line">762</span><br><span class="line">763</span><br><span class="line">764</span><br><span class="line">765</span><br><span class="line">766</span><br><span class="line">767</span><br><span class="line">768</span><br><span class="line">769</span><br><span class="line">770</span><br><span class="line">771</span><br><span class="line">772</span><br><span class="line">773</span><br><span class="line">774</span><br><span class="line">775</span><br><span class="line">776</span><br><span class="line">777</span><br><span class="line">778</span><br><span class="line">779</span><br><span class="line">780</span><br><span class="line">781</span><br><span class="line">782</span><br><span class="line">783</span><br><span class="line">784</span><br><span class="line">785</span><br><span class="line">786</span><br><span class="line">787</span><br><span class="line">788</span><br><span class="line">789</span><br><span class="line">790</span><br><span class="line">791</span><br><span class="line">792</span><br><span class="line">793</span><br><span class="line">794</span><br><span class="line">795</span><br><span class="line">796</span><br><span class="line">797</span><br><span class="line">798</span><br><span class="line">799</span><br><span class="line">800</span><br><span class="line">801</span><br><span class="line">802</span><br><span class="line">803</span><br><span class="line">804</span><br><span class="line">805</span><br><span class="line">806</span><br><span class="line">807</span><br><span class="line">808</span><br><span class="line">809</span><br><span class="line">810</span><br><span class="line">811</span><br><span class="line">812</span><br><span class="line">813</span><br><span class="line">814</span><br><span class="line">815</span><br><span class="line">816</span><br><span class="line">817</span><br><span class="line">818</span><br><span class="line">819</span><br><span class="line">820</span><br><span class="line">821</span><br><span class="line">822</span><br><span class="line">823</span><br><span class="line">824</span><br><span class="line">825</span><br><span class="line">826</span><br><span class="line">827</span><br><span class="line">828</span><br><span class="line">829</span><br><span class="line">830</span><br><span class="line">831</span><br><span class="line">832</span><br><span class="line">833</span><br><span class="line">834</span><br><span class="line">835</span><br><span class="line">836</span><br><span class="line">837</span><br><span class="line">838</span><br><span class="line">839</span><br><span class="line">840</span><br><span class="line">841</span><br><span class="line">842</span><br><span class="line">843</span><br><span class="line">844</span><br><span class="line">845</span><br><span class="line">846</span><br><span class="line">847</span><br><span class="line">848</span><br><span class="line">849</span><br><span class="line">850</span><br><span class="line">851</span><br><span class="line">852</span><br><span class="line">853</span><br><span class="line">854</span><br><span class="line">855</span><br><span class="line">856</span><br><span class="line">857</span><br><span class="line">858</span><br><span class="line">859</span><br><span class="line">860</span><br><span class="line">861</span><br><span class="line">862</span><br><span class="line">863</span><br><span class="line">864</span><br><span class="line">865</span><br><span class="line">866</span><br><span class="line">867</span><br><span class="line">868</span><br><span class="line">869</span><br><span class="line">870</span><br><span class="line">871</span><br><span class="line">872</span><br><span class="line">873</span><br><span class="line">874</span><br><span class="line">875</span><br><span class="line">876</span><br><span class="line">877</span><br><span class="line">878</span><br><span class="line">879</span><br><span class="line">880</span><br><span class="line">881</span><br><span class="line">882</span><br><span class="line">883</span><br><span class="line">884</span><br><span class="line">885</span><br><span class="line">886</span><br><span class="line">887</span><br><span class="line">888</span><br><span class="line">889</span><br><span class="line">890</span><br><span class="line">891</span><br><span class="line">892</span><br><span class="line">893</span><br><span class="line">894</span><br><span class="line">895</span><br><span class="line">896</span><br><span class="line">897</span><br><span class="line">898</span><br><span class="line">899</span><br><span class="line">900</span><br><span class="line">901</span><br><span class="line">902</span><br><span class="line">903</span><br><span class="line">904</span><br><span class="line">905</span><br><span class="line">906</span><br><span class="line">907</span><br><span class="line">908</span><br><span class="line">909</span><br><span class="line">910</span><br><span class="line">911</span><br><span class="line">912</span><br><span class="line">913</span><br><span class="line">914</span><br><span class="line">915</span><br><span class="line">916</span><br><span class="line">917</span><br><span class="line">918</span><br><span class="line">919</span><br><span class="line">920</span><br><span class="line">921</span><br><span class="line">922</span><br><span class="line">923</span><br><span class="line">924</span><br><span class="line">925</span><br><span class="line">926</span><br><span class="line">927</span><br><span class="line">928</span><br><span class="line">929</span><br><span class="line">930</span><br><span class="line">931</span><br><span class="line">932</span><br><span class="line">933</span><br><span class="line">934</span><br><span class="line">935</span><br><span class="line">936</span><br><span class="line">937</span><br><span class="line">938</span><br><span class="line">939</span><br><span class="line">940</span><br><span class="line">941</span><br><span class="line">942</span><br><span class="line">943</span><br><span class="line">944</span><br><span class="line">945</span><br><span class="line">946</span><br><span class="line">947</span><br><span class="line">948</span><br><span class="line">949</span><br><span class="line">950</span><br><span class="line">951</span><br><span class="line">952</span><br><span class="line">953</span><br><span class="line">954</span><br><span class="line">955</span><br><span class="line">956</span><br><span class="line">957</span><br><span class="line">958</span><br><span class="line">959</span><br><span class="line">960</span><br><span class="line">961</span><br><span class="line">962</span><br><span class="line">963</span><br><span class="line">964</span><br><span class="line">965</span><br><span class="line">966</span><br><span class="line">967</span><br><span class="line">968</span><br><span class="line">969</span><br><span class="line">970</span><br><span class="line">971</span><br><span class="line">972</span><br><span class="line">973</span><br><span class="line">974</span><br><span class="line">975</span><br><span class="line">976</span><br><span class="line">977</span><br><span class="line">978</span><br><span class="line">979</span><br><span class="line">980</span><br><span class="line">981</span><br><span class="line">982</span><br><span class="line">983</span><br><span class="line">984</span><br><span class="line">985</span><br><span class="line">986</span><br><span class="line">987</span><br><span class="line">988</span><br><span class="line">989</span><br><span class="line">990</span><br><span class="line">991</span><br><span class="line">992</span><br><span class="line">993</span><br><span class="line">994</span><br><span class="line">995</span><br><span class="line">996</span><br><span class="line">997</span><br><span class="line">998</span><br><span class="line">999</span><br><span class="line">1000</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractQueuedSynchronizer</span><br>    <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractOwnableSynchronizer</span><br>    <span class="hljs-keyword">implements</span> <span class="hljs-title class_">java</span>.io.Serializable&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">7373984972572414691L</span>;<br><br>    <span class="hljs-comment">// Creates a new AbstractQueuedSynchronizer instance with initial synchronization state of zero.</span><br>    <span class="hljs-comment">// 创建一个初始同步状态为0的 AbstractQueuedSynchronizer 实例</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">AbstractQueuedSynchronizer</span><span class="hljs-params">()</span> &#123; &#125;<br><br>    <span class="hljs-comment">// Node status bits, also used as argument and return values</span><br>    <span class="hljs-comment">// 节点状态位，也用来作为argument和返回值</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">WAITING</span>   <span class="hljs-operator">=</span> <span class="hljs-number">1</span>;          <span class="hljs-comment">// must be 1</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">CANCELLED</span> <span class="hljs-operator">=</span> <span class="hljs-number">0x80000000</span>; <span class="hljs-comment">// must be negative</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">COND</span>      <span class="hljs-operator">=</span> <span class="hljs-number">2</span>;          <span class="hljs-comment">// in a condition wait</span><br><br>    <span class="hljs-comment">// Unsafe</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">U</span> <span class="hljs-operator">=</span> Unsafe.getUnsafe();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">STATE</span><br>        <span class="hljs-operator">=</span> U.objectFieldOffset(AbstractQueuedSynchronizer.class, <span class="hljs-string">&quot;state&quot;</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">HEAD</span><br>        <span class="hljs-operator">=</span> U.objectFieldOffset(AbstractQueuedSynchronizer.class, <span class="hljs-string">&quot;head&quot;</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">TAIL</span><br>        <span class="hljs-operator">=</span> U.objectFieldOffset(AbstractQueuedSynchronizer.class, <span class="hljs-string">&quot;tail&quot;</span>);<br><br>    <span class="hljs-keyword">static</span> &#123;<br>        Class&lt;?&gt; ensureLoaded = LockSupport.class;<br>    &#125; <br><br>    <span class="hljs-comment">// CLH 节点</span><br>    <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Node</span> &#123;<br>        <span class="hljs-comment">// initially attached via casTail</span><br>        <span class="hljs-keyword">volatile</span> Node prev;  <br>        <span class="hljs-comment">// visibly（明显地） nonnull when signallable</span><br>        <span class="hljs-keyword">volatile</span> Node next;  <br>        <span class="hljs-comment">// visibly nonnull when enqueued     </span><br>        Thread waiter;   <br>        <span class="hljs-comment">// written by owner, atomic bit ops by others         </span><br>        <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> status;   <br><br>        <span class="hljs-comment">// 获取类中属性的偏移量，用于后续cas操作</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">STATUS</span><br>            <span class="hljs-operator">=</span> U.objectFieldOffset(Node.class, <span class="hljs-string">&quot;status&quot;</span>);<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">NEXT</span><br>            <span class="hljs-operator">=</span> U.objectFieldOffset(Node.class, <span class="hljs-string">&quot;next&quot;</span>);<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">PREV</span><br>            <span class="hljs-operator">=</span> U.objectFieldOffset(Node.class, <span class="hljs-string">&quot;prev&quot;</span>);   <br><br>        <span class="hljs-comment">// methods for atomic operations</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">casPrev</span><span class="hljs-params">(Node c, Node v)</span> &#123;  <span class="hljs-comment">// for cleanQueue</span><br>            <span class="hljs-keyword">return</span> U.weakCompareAndSetReference(<span class="hljs-built_in">this</span>, PREV, c, v);<br>        &#125;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">casNext</span><span class="hljs-params">(Node c, Node v)</span> &#123;  <span class="hljs-comment">// for cleanQueue</span><br>            <span class="hljs-keyword">return</span> U.weakCompareAndSetReference(<span class="hljs-built_in">this</span>, NEXT, c, v);<br>        &#125;<br>        <span class="hljs-comment">// 将状态置为0，并返回操作之前的值</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getAndUnsetStatus</span><span class="hljs-params">(<span class="hljs-type">int</span> v)</span> &#123;     <span class="hljs-comment">// for signalling</span><br>            <span class="hljs-comment">// 用当前值和掩码之间按位AND的结果自动替换</span><br>            <span class="hljs-comment">// 给定对象中字段或数组元素的当前值，返回之前的值</span><br>            <span class="hljs-keyword">return</span> U.getAndBitwiseAndInt(<span class="hljs-built_in">this</span>, STATUS, ~v);<br>        &#125;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setPrevRelaxed</span><span class="hljs-params">(Node p)</span> &#123;      <span class="hljs-comment">// for off-queue assignment</span><br>            <span class="hljs-comment">// 将引用值存储到对应的java变量中</span><br>            U.putReference(<span class="hljs-built_in">this</span>, PREV, p);<br>        &#125;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setStatusRelaxed</span><span class="hljs-params">(<span class="hljs-type">int</span> s)</span> &#123;     <span class="hljs-comment">// for off-queue assignment</span><br>            U.putInt(<span class="hljs-built_in">this</span>, STATUS, s);<br>        &#125;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">clearStatus</span><span class="hljs-params">()</span> &#123;               <span class="hljs-comment">// for reducing unneeded signals</span><br>            <span class="hljs-comment">// putIntVolatile(Object, long, int)的不透明版本</span><br>            U.putIntOpaque(<span class="hljs-built_in">this</span>, STATUS, <span class="hljs-number">0</span>);<br>        &#125;<br><br>    &#125; <br><br>    <span class="hljs-comment">// Concrete classes tagged by type</span><br>    <span class="hljs-comment">// 按类型标记的具体类</span><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExclusiveNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span> &#123; &#125;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SharedNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span> &#123; &#125; <br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionNode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Node</span><br>        <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ForkJoinPool</span>.ManagedBlocker &#123; <br>        <span class="hljs-comment">// link to next waiting node</span><br>        ConditionNode nextWaiter;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Allows Conditions to be used in ForkJoinPools without</span><br><span class="hljs-comment">         * risking fixed pool exhaustion. This is usable only for</span><br><span class="hljs-comment">         * untimed Condition waits, not timed versions.</span><br><span class="hljs-comment">         * 允许在ForkJoinPools中使用条件，而不会有固定池耗尽的风险。</span><br><span class="hljs-comment">         * 这仅适用于无计时条件等待，不适用于计时版本。</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isReleasable</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">return</span> status &lt;= <span class="hljs-number">1</span> || Thread.currentThread().isInterrupted();<br>        &#125;<br><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">block</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">while</span> (!isReleasable()) LockSupport.park();<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125; <br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Head of the wait queue, lazily initialized. 懒惰初始化</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node head;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Tail of the wait queue. After initialization, modified only via casTail. </span><br><span class="hljs-comment">     * 初始化过后，仅通过casTail修改</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> <span class="hljs-keyword">volatile</span> Node tail;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The synchronization state. 同步状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-type">int</span> state; <br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getState</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> state;<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setState</span><span class="hljs-params">(<span class="hljs-type">int</span> newState)</span> &#123;<br>        state = newState;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置状态cas操作</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">compareAndSetState</span><span class="hljs-params">(<span class="hljs-type">int</span> expect, <span class="hljs-type">int</span> update)</span> &#123;<br>        <span class="hljs-keyword">return</span> U.compareAndSetInt(<span class="hljs-built_in">this</span>, STATE, expect, update);<br>    &#125;  <br><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">casTail</span><span class="hljs-params">(Node c, Node v)</span> &#123;<br>        <span class="hljs-keyword">return</span> U.compareAndSetReference(<span class="hljs-built_in">this</span>, TAIL, c, v);<br>    &#125;<br><br>    <span class="hljs-comment">/** tries once to CAS a new dummy node for head </span><br><span class="hljs-comment">     *  将head设置为一个新的dummy节点，使用cas操作，只尝试一次</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">tryInitializeHead</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Node</span> <span class="hljs-variable">h</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExclusiveNode</span>();<br>        <span class="hljs-keyword">if</span> (U.compareAndSetReference(<span class="hljs-built_in">this</span>, HEAD, <span class="hljs-literal">null</span>, h))<br>            tail = h;<br>    &#125; <br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Enqueues the node unless null. (Currently used only for</span><br><span class="hljs-comment">     * ConditionNodes; other cases are interleaved with acquires.) </span><br><span class="hljs-comment">     * 当前仅用于ConditionNodes；其他情况与acquire交错进行。</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">enqueue</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (;;) &#123;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>                <span class="hljs-comment">// avoid unnecessary fence（避免不必要的围栏？）</span><br>                <span class="hljs-comment">// 这里没有使用volatile变量对应的方法</span><br>                node.setPrevRelaxed(t);        <br>                <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)                 <span class="hljs-comment">// initialize</span><br>                    tryInitializeHead();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (casTail(t, node)) &#123;<br>                    t.next = node;<br>                    <span class="hljs-keyword">if</span> (t.status &lt; <span class="hljs-number">0</span>)          <span class="hljs-comment">// wake up to clean link</span><br>                        LockSupport.unpark(node.waiter);<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <br><br>    <span class="hljs-comment">/** Returns true if node is found in traversal from tail </span><br><span class="hljs-comment">     *  节点已在队列中（从后向前找）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isEnqueued</span><span class="hljs-params">(Node node)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail; t != <span class="hljs-literal">null</span>; t = t.prev)<br>            <span class="hljs-keyword">if</span> (t == node)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <br><br>    <span class="hljs-comment">// 唤醒给定节点的后继节点(如果存在),并取消其等待状态以避免park竞争。</span><br>    <span class="hljs-comment">// 当一个或多个线程被取消时，这可能无法唤醒符合条件的线程，</span><br>    <span class="hljs-comment">// 但cancelAcquire确保了（线程？）存活。</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalNext</span><span class="hljs-params">(Node h)</span> &#123;<br>        Node s;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; (s = h.next) != <span class="hljs-literal">null</span> &amp;&amp; s.status != <span class="hljs-number">0</span>) &#123;<br>            s.getAndUnsetStatus(WAITING);<br>            LockSupport.unpark(s.waiter);<br>        &#125;<br>    &#125; <br><br>    <span class="hljs-comment">/** Wakes up the given node if in shared mode （共享模式）*/</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalNextIfShared</span><span class="hljs-params">(Node h)</span> &#123;<br>        Node s;<br>        <span class="hljs-keyword">if</span> (h != <span class="hljs-literal">null</span> &amp;&amp; (s = h.next) != <span class="hljs-literal">null</span> &amp;&amp;<br>            (s <span class="hljs-keyword">instanceof</span> SharedNode) &amp;&amp; s.status != <span class="hljs-number">0</span>) &#123;<br>            s.getAndUnsetStatus(WAITING);<br>            LockSupport.unpark(s.waiter);<br>        &#125;<br>    &#125; <br><br>    <span class="hljs-comment">// Main acquire method, invoked by all exported acquire methods.</span><br>    <span class="hljs-comment">// 主要的acquire方法，被所有暴露的acquire方法调用</span><br>    <span class="hljs-comment">// 返回值：positive if acquired, 0 if timed out, negative if interrupted</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(Node node, <span class="hljs-type">int</span> arg, <span class="hljs-type">boolean</span> shared,</span><br><span class="hljs-params">                      <span class="hljs-type">boolean</span> interruptible, <span class="hljs-type">boolean</span> timed, <span class="hljs-type">long</span> time)</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">current</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>        <span class="hljs-comment">// unpark 第一个线程后第一个线程的重试次数</span><br>        <span class="hljs-type">byte</span> <span class="hljs-variable">spins</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, postSpins = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, first = <span class="hljs-literal">false</span>;<br>        <span class="hljs-comment">// node入队时的前驱节点</span><br>        <span class="hljs-type">Node</span> <span class="hljs-variable">pred</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><br>        <span class="hljs-comment">// 检查节点node现在是否是第一个节点，如果是的话，确保head稳定，否则保证有效的前驱</span><br>        <span class="hljs-comment">// 如果节点是第一个或尚未入队，尝试acquire</span><br>        <span class="hljs-comment">// 否则如果节点还没有创建，创建它</span><br>        <span class="hljs-comment">// 否则如果节点还没有入队，尝试入队一次</span><br>        <span class="hljs-comment">// 否则如果节点被park唤醒，重试（一直到 postSpins 次）</span><br>        <span class="hljs-comment">// 否则如果WAITING状态还没有被设置，设置并重试</span><br>        <span class="hljs-comment">// 否则，park并且清除WAITING状态，并且检查取消</span><br>        <span class="hljs-comment">// 翻译的注释，可以参考</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-comment">// first表示node的前驱节点是否为head，即node是否是第一个节点</span><br>            <span class="hljs-keyword">if</span> (!first &amp;&amp; (pred = (node == <span class="hljs-literal">null</span>) ? <span class="hljs-literal">null</span> : node.prev) != <span class="hljs-literal">null</span> &amp;&amp;<br>                !(first = (head == pred))) &#123;<br>                <span class="hljs-keyword">if</span> (pred.status &lt; <span class="hljs-number">0</span>) &#123;<br>                    cleanQueue();           <span class="hljs-comment">// predecessor cancelled</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pred.prev == <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-comment">// 队列断了（pred不是head，但是其前驱为null），确保队列连续</span><br>                    <span class="hljs-comment">// 为什么会出现这种情况？</span><br>                    Thread.onSpinWait();    <span class="hljs-comment">// ensure serialization</span><br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>            &#125; <br>            <span class="hljs-comment">// node是第一个节点或者node还没有入队（非公平竞争）</span><br>            <span class="hljs-comment">// 有竞争的资格</span><br>            <span class="hljs-keyword">if</span> (first || pred == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">boolean</span> acquired;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">if</span> (shared)<br>                        acquired = (tryAcquireShared(arg) &gt;= <span class="hljs-number">0</span>);<br>                    <span class="hljs-keyword">else</span><br>                        acquired = tryAcquire(arg);<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable ex) &#123; <br>                    <span class="hljs-comment">// 出现异常、取消正在进行的acquire尝试</span><br>                    cancelAcquire(node, interrupted, <span class="hljs-literal">false</span>);<br>                    <span class="hljs-keyword">throw</span> ex;<br>                &#125;   <br>                <span class="hljs-keyword">if</span> (acquired) &#123;<br>                    <span class="hljs-keyword">if</span> (first) &#123;<br>                        <span class="hljs-comment">// 竞争成功后将node（第一个节点）设为head</span><br>                        node.prev = <span class="hljs-literal">null</span>;<br>                        head = node;<br>                        <span class="hljs-comment">// 将之前的head属性置空，方便GC</span><br>                        pred.next = <span class="hljs-literal">null</span>;<br>                        node.waiter = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">if</span> (shared) &#123;<br>                            <span class="hljs-comment">// 如果下个节点（第一个节点）是SharedNode，将其唤醒</span><br>                            <span class="hljs-comment">// 配合能重复成功的 tryAcquireShared 能实现一次</span><br>                            <span class="hljs-comment">// 出队多个节点的效果</span><br>                            signalNextIfShared(node);<br>                        &#125;  <br>                        <span class="hljs-keyword">if</span> (interrupted)<br>                            current.interrupt(); <span class="hljs-comment">// 清空线程的打断状态</span><br>                    &#125;<br>                    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>                &#125;             <br>            &#125; <br>            <span class="hljs-comment">// allocate; retry before enqueue</span><br>            <span class="hljs-comment">// 新建node，在入队时再次尝试，这里对应上段代码pred == null条件</span><br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span>) &#123;                 <br>                <span class="hljs-keyword">if</span> (shared)<br>                    node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SharedNode</span>();<br>                <span class="hljs-keyword">else</span><br>                    node = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ExclusiveNode</span>();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pred == <span class="hljs-literal">null</span>) &#123;  <br>                <span class="hljs-comment">// try to enqueue</span><br>                <span class="hljs-comment">// 新建的node竞争失败，入队</span><br>                node.waiter = current;<br>                <span class="hljs-type">Node</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> tail;<br>                node.setPrevRelaxed(t);         <span class="hljs-comment">// avoid unnecessary fence</span><br>                <span class="hljs-keyword">if</span> (t == <span class="hljs-literal">null</span>)<br>                    tryInitializeHead();<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!casTail(t, node))<br>                    node.setPrevRelaxed(<span class="hljs-literal">null</span>);  <span class="hljs-comment">// back out</span><br>                <span class="hljs-keyword">else</span><br>                    t.next = node;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (first &amp;&amp; spins != <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// reduce unfairness on rewaits</span><br>                <span class="hljs-comment">// 队列中第一个节点第二次开始竞争的时候有自旋次数</span><br>                --spins;              <br>                Thread.onSpinWait();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (node.status == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// enable signal and recheck</span><br>                <span class="hljs-comment">// 自旋竞争失败后重新等待</span><br>                node.status = WAITING;          <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">long</span> nanos;<br>                <span class="hljs-comment">// 自旋次数</span><br>                spins = postSpins = (<span class="hljs-type">byte</span>)((postSpins &lt;&lt; <span class="hljs-number">1</span>) | <span class="hljs-number">1</span>);<br>                <span class="hljs-keyword">if</span> (!timed)<br>                    LockSupport.park(<span class="hljs-built_in">this</span>);<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((nanos = time - System.nanoTime()) &gt; <span class="hljs-number">0L</span>)<br>                    LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>                <span class="hljs-keyword">else</span><br>                    <span class="hljs-keyword">break</span>;<br>                node.clearStatus();<br>                <span class="hljs-comment">/// 可打断并已经打断，放弃acquire</span><br>                <span class="hljs-keyword">if</span> ((interrupted |= Thread.interrupted()) &amp;&amp; interruptible)<br>                    <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> cancelAcquire(node, interrupted, interruptible);<br>    &#125; <br><br>    <span class="hljs-comment">// 可能从尾部开始重复遍历</span><br>    <span class="hljs-comment">// 将已取消的节点从队列中剔除，直到找不到已取消节点</span><br>    <span class="hljs-comment">// unpark可能已被重新链接为下一个合格的acquirer的节点</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">cleanQueue</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (;;) &#123;                               <span class="hljs-comment">// restart point </span><br>            <span class="hljs-comment">// q为要检查的node，p为q的前驱节点，s为q的后继节点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> tail, s = <span class="hljs-literal">null</span>, p, n;;) &#123; <span class="hljs-comment">// (p, q, s) triples</span><br>                <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span> || (p = q.prev) == <span class="hljs-literal">null</span>)<br>                    <span class="hljs-keyword">return</span>;                      <span class="hljs-comment">// end of list</span><br>                <span class="hljs-keyword">if</span> (s == <span class="hljs-literal">null</span> ? tail != q : (s.prev != q || s.status &lt; <span class="hljs-number">0</span>))<br>                    <span class="hljs-keyword">break</span>;                       <span class="hljs-comment">// inconsistent</span><br>                <span class="hljs-keyword">if</span> (q.status &lt; <span class="hljs-number">0</span>) &#123;              <span class="hljs-comment">// cancelled</span><br>                    <span class="hljs-keyword">if</span> ((s == <span class="hljs-literal">null</span> ? casTail(q, p) : s.casPrev(q, p)) &amp;&amp;<br>                        q.prev == p) &#123;<br>                        p.casNext(q, s);         <span class="hljs-comment">// OK if fails</span><br>                        <span class="hljs-keyword">if</span> (p.prev == <span class="hljs-literal">null</span>)<br>                            signalNext(p);<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                <span class="hljs-comment">// 下面的代码应该是考虑到了并发，对应上面的</span><br>                <span class="hljs-comment">// p.casNext(q, s); 还未开始</span><br>                <span class="hljs-keyword">if</span> ((n = p.next) != q) &#123;         <span class="hljs-comment">// help finish</span><br>                    <span class="hljs-keyword">if</span> (n != <span class="hljs-literal">null</span> &amp;&amp; q.prev == p) &#123;<br>                        p.casNext(n, q);<br>                        <span class="hljs-keyword">if</span> (p.prev == <span class="hljs-literal">null</span>)<br>                            signalNext(p);<br>                    &#125;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>                s = q;<br>                q = q.prev;<br>            &#125;<br>        &#125;<br>    &#125; <br><br>    <span class="hljs-comment">// interrupted：如果线程中断，则为true</span><br>    <span class="hljs-comment">// interruptible：是否应该报告中断和复位</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">cancelAcquire</span><span class="hljs-params">(Node node, <span class="hljs-type">boolean</span> interrupted,</span><br><span class="hljs-params">                              <span class="hljs-type">boolean</span> interruptible)</span> &#123;<br>        <span class="hljs-keyword">if</span> (node != <span class="hljs-literal">null</span>) &#123;<br>            node.waiter = <span class="hljs-literal">null</span>;<br>            node.status = CANCELLED;<br>            <span class="hljs-keyword">if</span> (node.prev != <span class="hljs-literal">null</span>)<br>                cleanQueue();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (interrupted) &#123;<br>            <span class="hljs-keyword">if</span> (interruptible)<br>                <span class="hljs-keyword">return</span> CANCELLED;<br>            <span class="hljs-keyword">else</span><br>                Thread.currentThread().interrupt();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125; <br><br>    <span class="hljs-comment">// 试图以独占模式获取。此方法应该查询对象的状态是否允许以独占模式获取它，如果允许，就获取它。</span><br>    <span class="hljs-comment">// 该方法总是由执行acquire的线程调用。</span><br>    <span class="hljs-comment">// 如果这个方法报错，如果线程还没有排队，那么acquire方法可以将线程排队</span><br>    <span class="hljs-comment">// 直到它被某个其他线程的释放唤醒</span><br>    <span class="hljs-comment">// 这可用于实现方法Lock.tryLock()。</span><br>    <span class="hljs-comment">// arg：获取参数。该值始终是传递给acquire方法的值，</span><br>    <span class="hljs-comment">// 或者是在进入条件等待时保存的值。该值不需要解释，可以表示您喜欢的任何内容。</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125; <br><br>    <span class="hljs-comment">// 尝试设置状态以反映独占模式下的释放。</span><br>    <span class="hljs-comment">// 该方法总是由执行释放的线程调用</span><br>    <span class="hljs-comment">// 返回值：如果此对象现在处于完全释放状态，则为true，以便任何等待的线程都可以尝试获取；否则为false。</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryRelease</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125; <br><br>    <span class="hljs-comment">// 尝试在共享模式下获取。此方法应该查询对象的状态是否允许在共享模式下获取它，如果允许，就获取它。</span><br>    <span class="hljs-comment">// 该方法总是由执行acquire的线程调用。</span><br>    <span class="hljs-comment">// 如果这个方法报告失败，如果线程还没有排队，那么acquire方法可以将线程排队，</span><br>    <span class="hljs-comment">// 直到它被某个其他线程的释放唤醒。</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">int</span> <span class="hljs-title function_">tryAcquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125; <br><br>    <span class="hljs-comment">// 返回值：如果共享模式的这一释放可以允许等待的获取(共享或独占)成功，则为true否则为false</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryReleaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125; <br><br>    <span class="hljs-comment">// 如果同步是相对于当前(调用)线程独占保持的，则返回true。</span><br>    <span class="hljs-comment">// 每次调用AbstractQueuedSynchronizer时都会调用此方法。条件对象方法。</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isHeldExclusively</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">UnsupportedOperationException</span>();<br>    &#125; <br><br>    <span class="hljs-comment">// 在独占模式下acquire，忽略中断。</span><br>    <span class="hljs-comment">// 通过至少调用一次tryAcquire来实现，成功时返回。</span><br>    <span class="hljs-comment">// 否则线程被排队，可能重复阻塞和解除阻塞，调用tryAcquire直到成功。</span><br>    <span class="hljs-comment">// 此方法可用于实现方法Lock.lock。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquire</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!tryAcquire(arg))<br>            acquire(<span class="hljs-literal">null</span>, arg, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>    &#125; <br><br>    <span class="hljs-comment">// 在独占模式下acquire，如果被中断则中止。</span><br>    <span class="hljs-comment">// 首先检查中断状态，然后至少调用一次tryAcquire，成功后返回。</span><br>    <span class="hljs-comment">// 否则线程被排队，可能重复阻塞和解除阻塞，调用tryAcquire直到成功或线程被中断。</span><br>    <span class="hljs-comment">// 此方法可用于实现方法 Lock.lockInterruptibly。 </span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (Thread.interrupted() ||<br>            (!tryAcquire(arg) &amp;&amp; acquire(<span class="hljs-literal">null</span>, arg, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>) &lt; <span class="hljs-number">0</span>))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    &#125; <br><br>    <span class="hljs-comment">// 尝试以独占模式acquire，如果被中断则中止，如果超时则失败。</span><br>    <span class="hljs-comment">// 首先检查中断状态，然后至少调用一次tryAcquire，成功后返回。</span><br>    <span class="hljs-comment">// 否则，线程被排队，可能重复阻塞和解除阻塞，调用tryAcquire，直到成功或线程被中断或超时。</span><br>    <span class="hljs-comment">// 此方法可用于实现方法Lock.tryLock(long，TimeUnit)。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquireNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (!Thread.interrupted()) &#123;<br>            <span class="hljs-keyword">if</span> (tryAcquire(arg))<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> acquire(<span class="hljs-literal">null</span>, arg, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>,<br>                               System.nanoTime() + nanosTimeout);<br>            <span class="hljs-keyword">if</span> (stat &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (stat == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    &#125; <br><br>    <span class="hljs-comment">// 以独占模式释放。</span><br>    <span class="hljs-comment">// 如果tryRelease返回true，则通过解除一个或多个线程的阻塞来实现。</span><br>    <span class="hljs-comment">// 此方法可用于实现方法Lock.unlock。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (tryRelease(arg)) &#123;<br>            signalNext(head);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <br><br>    <span class="hljs-comment">// 在share mode时acquire</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span>)<br>            acquire(<span class="hljs-literal">null</span>, arg, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>    &#125; <br><br>    <span class="hljs-comment">// 在share mode时 acquireInterruptibly</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">acquireSharedInterruptibly</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span><br>        <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (Thread.interrupted() ||<br>            (tryAcquireShared(arg) &lt; <span class="hljs-number">0</span> &amp;&amp;<br>             acquire(<span class="hljs-literal">null</span>, arg, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>) &lt; <span class="hljs-number">0</span>))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    &#125; <br><br>    <span class="hljs-comment">// 在share mode时 tryAcquireNanos</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryAcquireSharedNanos</span><span class="hljs-params">(<span class="hljs-type">int</span> arg, <span class="hljs-type">long</span> nanosTimeout)</span><br>            <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>        <span class="hljs-keyword">if</span> (!Thread.interrupted()) &#123;<br>            <span class="hljs-keyword">if</span> (tryAcquireShared(arg) &gt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (nanosTimeout &lt;= <span class="hljs-number">0L</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">stat</span> <span class="hljs-operator">=</span> acquire(<span class="hljs-literal">null</span>, arg, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>,<br>                               System.nanoTime() + nanosTimeout);<br>            <span class="hljs-keyword">if</span> (stat &gt; <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">if</span> (stat == <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>    &#125; <br><br>    <span class="hljs-comment">// 在share mode时 release</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">releaseShared</span><span class="hljs-params">(<span class="hljs-type">int</span> arg)</span> &#123;<br>        <span class="hljs-keyword">if</span> (tryReleaseShared(arg)) &#123;<br>            signalNext(head);<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <br><br>    <span class="hljs-comment">// 队列检查方法</span><br><br>    <span class="hljs-comment">// 查询是否有任何线程正在等待获取。</span><br>    <span class="hljs-comment">// 请注意，由于中断和超时导致的取消可能随时发生，所以返回true并不保证任何其他线程acquire成功。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasQueuedThreads</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> tail, h = head; p != h &amp;&amp; p != <span class="hljs-literal">null</span>; p = p.prev)<br>            <span class="hljs-keyword">if</span> (p.status &gt;= <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 查询是否有任何线程曾经竞争获取此同步器；</span><br>    <span class="hljs-comment">// 也就是说，是否有一个acquire方法曾经被阻塞。</span><br>    <span class="hljs-comment">// 在这个实现中，这个操作在常数时间内返回。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasContended</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> head != <span class="hljs-literal">null</span>;<br>    &#125; <br><br>    <span class="hljs-comment">// 返回队列中第一个(等待时间最长的)线程，如果当前没有线程排队，则返回null。</span><br>    <span class="hljs-comment">// 在该实现中，该操作通常在恒定时间内返回，但是如果其他线程同时修改队列，则可能在竞争时重复。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Thread <span class="hljs-title function_">getFirstQueuedThread</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, w; Node h, s;<br>        <span class="hljs-keyword">if</span> ((h = head) != <span class="hljs-literal">null</span> &amp;&amp; ((s = h.next) == <span class="hljs-literal">null</span> ||<br>                                   (first = s.waiter) == <span class="hljs-literal">null</span> ||<br>                                   s.prev == <span class="hljs-literal">null</span>)) &#123;<br>            <span class="hljs-comment">// traverse from tail on stale reads </span><br>            <span class="hljs-comment">// q存储p的前驱节点</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> tail, q; p != <span class="hljs-literal">null</span> &amp;&amp; (q = p.prev) != <span class="hljs-literal">null</span>; p = q)<br>                <span class="hljs-keyword">if</span> ((w = p.waiter) != <span class="hljs-literal">null</span>)<br>                    first = w;<br>        &#125;<br>        <span class="hljs-keyword">return</span> first;<br>    &#125; <br><br>    <span class="hljs-comment">// 如果给定线程当前正在排队，则返回true。</span><br>    <span class="hljs-comment">// 该实现遍历队列以确定给定线程的存在。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isQueued</span><span class="hljs-params">(Thread thread)</span> &#123;<br>        <span class="hljs-keyword">if</span> (thread == <span class="hljs-literal">null</span>)<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> tail; p != <span class="hljs-literal">null</span>; p = p.prev)<br>            <span class="hljs-keyword">if</span> (p.waiter == thread)<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125; <br><br>    <span class="hljs-comment">// 如果明面上的第一个排队线程(如果存在)正在以独占模式等待，则返回true。</span><br>    <span class="hljs-comment">// 如果此方法返回true，并且当前线程正在尝试以共享模式获取(即，此方法是从tryAcquireShared调用的)，</span><br>    <span class="hljs-comment">// 则可以保证当前线程不是第一个排队的线程。在ReentrantReadWriteLock中仅用作启发式方法。</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">apparentlyFirstQueuedIsExclusive</span><span class="hljs-params">()</span> &#123;<br>        Node h, s;<br>        <span class="hljs-keyword">return</span> (h = head) != <span class="hljs-literal">null</span> &amp;&amp; (s = h.next)  != <span class="hljs-literal">null</span> &amp;&amp;<br>            !(s <span class="hljs-keyword">instanceof</span> SharedNode) &amp;&amp; s.waiter != <span class="hljs-literal">null</span>;<br>    &#125; <br><br>    <span class="hljs-comment">// 查询是否有任何线程等待获取的时间比当前线程长。</span><br>    <span class="hljs-comment">// 此方法的调用等效于(但可能更有效):</span><br>    <span class="hljs-comment">// getFirstQueuedThread() != Thread.currentThread() &amp;&amp; hasQueuedThreads()</span><br>    <span class="hljs-comment">// 请注意，由于中断和超时导致的取消可能会在任何时候发生，</span><br>    <span class="hljs-comment">// 所以真正的返回并不保证其他线程会在当前线程之前获取。</span><br>    <span class="hljs-comment">// 同样，由于队列为空，在此方法返回false后，另一个赢得竞争的线程也可能排队。</span><br>    <span class="hljs-comment">// 该方法被设计为由公平同步器使用以避免冲突。</span><br>    <span class="hljs-comment">// 这样一个同步器的tryAcquire方法应该返回false，</span><br>    <span class="hljs-comment">// 它的tryAcquireShared方法应该返回负值，如果这个方法返回true的话(除非这是一个可重入的Acquire)。</span><br>    <span class="hljs-comment">// 例如，公平、可重入、独占模式同步器的tryAcquire方法可能如下所示</span><br>    <span class="hljs-comment">// protected boolean tryAcquire(int arg) &#123;</span><br>    <span class="hljs-comment">//   if (isHeldExclusively()) &#123;</span><br>    <span class="hljs-comment">//     // A reentrant acquire; increment hold count</span><br>    <span class="hljs-comment">//     return true;</span><br>    <span class="hljs-comment">//   &#125; else if (hasQueuedPredecessors()) &#123;</span><br>    <span class="hljs-comment">//     return false;</span><br>    <span class="hljs-comment">//   &#125; else &#123;</span><br>    <span class="hljs-comment">//     // try to acquire normally</span><br>    <span class="hljs-comment">//   &#125;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasQueuedPredecessors</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">Thread</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>; Node h, s;<br>        <span class="hljs-keyword">if</span> ((h = head) != <span class="hljs-literal">null</span> &amp;&amp; ((s = h.next) == <span class="hljs-literal">null</span> ||<br>                                   (first = s.waiter) == <span class="hljs-literal">null</span> ||<br>                                   s.prev == <span class="hljs-literal">null</span>)) <br>            <span class="hljs-comment">// 这里的判断在 getFirstQueuedThread 已经有了，我觉得可以去掉</span><br>            first = getFirstQueuedThread(); <span class="hljs-comment">// retry via getFirstQueuedThread</span><br>        <span class="hljs-keyword">return</span> first != <span class="hljs-literal">null</span> &amp;&amp; first != Thread.currentThread();<br>    &#125; <br><br>    <span class="hljs-comment">// 检测和监控方法</span><br><br>    <span class="hljs-comment">// 返回等待获取的线程数的估计值。</span><br>    <span class="hljs-comment">// 该值只是一个估计值，因为在此方法遍历内部数据结构时，线程的数量可能会动态变化。</span><br>    <span class="hljs-comment">// 此方法设计用于监视系统状态，而不是用于同步控制。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getQueueLength</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> tail; p != <span class="hljs-literal">null</span>; p = p.prev) &#123;<br>            <span class="hljs-keyword">if</span> (p.waiter != <span class="hljs-literal">null</span>)<br>                ++n;<br>        &#125;<br>        <span class="hljs-keyword">return</span> n;<br>    &#125; <br><br>    <span class="hljs-comment">// 返回包含可能正在等待获取的线程的集合。</span><br>    <span class="hljs-comment">// 因为实际的线程集在构造这个结果时可能会动态变化，</span><br>    <span class="hljs-comment">// 所以返回的集合只是一个最佳估计。</span><br>    <span class="hljs-comment">// 返回集合的元素没有特定的顺序。</span><br>    <span class="hljs-comment">// 该方法旨在促进子类的构建，从而提供更广泛的监控功能。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Collection&lt;Thread&gt; <span class="hljs-title function_">getQueuedThreads</span><span class="hljs-params">()</span> &#123;<br>        ArrayList&lt;Thread&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> tail; p != <span class="hljs-literal">null</span>; p = p.prev) &#123;<br>            <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> p.waiter;<br>            <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)<br>                list.add(t);<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125; <br><br>    <span class="hljs-comment">// 返回包含可能正在等待以独占模式acquire的线程的集合。</span><br>    <span class="hljs-comment">// 这与getQueuedThreads具有相同的属性，</span><br>    <span class="hljs-comment">// 只是它只返回那些由于独占获取而等待的线程。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Collection&lt;Thread&gt; <span class="hljs-title function_">getExclusiveQueuedThreads</span><span class="hljs-params">()</span> &#123;<br>        ArrayList&lt;Thread&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> tail; p != <span class="hljs-literal">null</span>; p = p.prev) &#123;<br>            <span class="hljs-keyword">if</span> (!(p <span class="hljs-keyword">instanceof</span> SharedNode)) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> p.waiter;<br>                <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)<br>                    list.add(t);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125; <br><br>    <span class="hljs-comment">// 返回包含可能正在等待以共享模式acquire的线程的集合。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Collection&lt;Thread&gt; <span class="hljs-title function_">getSharedQueuedThreads</span><span class="hljs-params">()</span> &#123;<br>        ArrayList&lt;Thread&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">Node</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> tail; p != <span class="hljs-literal">null</span>; p = p.prev) &#123;<br>            <span class="hljs-keyword">if</span> (p <span class="hljs-keyword">instanceof</span> SharedNode) &#123;<br>                <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> p.waiter;<br>                <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)<br>                    list.add(t);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> list;<br>    &#125; <br><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>.toString()<br>            + <span class="hljs-string">&quot;[State = &quot;</span> + getState() + <span class="hljs-string">&quot;, &quot;</span><br>            + (hasQueuedThreads() ? <span class="hljs-string">&quot;non&quot;</span> : <span class="hljs-string">&quot;&quot;</span>) + <span class="hljs-string">&quot;empty queue]&quot;</span>;<br>    &#125; <br><br>    <span class="hljs-comment">// conditions的检测方法</span><br><br>    <span class="hljs-comment">// 查询给定的ConditionObject是否使用此同步器作为其锁。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">owns</span><span class="hljs-params">(ConditionObject condition)</span> &#123;<br>        <span class="hljs-keyword">return</span> condition.isOwnedBy(<span class="hljs-built_in">this</span>);<br>    &#125; <br><br>    <span class="hljs-comment">// 查询是否有任何线程正在等待与此同步器关联的给定条件。</span><br>    <span class="hljs-comment">// 请注意，因为超时和中断可能随时发生，所以真正的返回并不保证将来的信号会唤醒任何线程。</span><br>    <span class="hljs-comment">// 这方法主要用于监控系统状态。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasWaiters</span><span class="hljs-params">(ConditionObject condition)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!owns(condition))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Not owner&quot;</span>);<br>        <span class="hljs-keyword">return</span> condition.hasWaiters();<br>    &#125;  <br><br>    <span class="hljs-comment">// 返回在与此同步器相关的给定条件下等待的线程数的估计值。</span><br>    <span class="hljs-comment">// 请注意，因为超时和中断可能随时发生，所以估计值只是实际等待者数量的上限。</span><br>    <span class="hljs-comment">// 此方法被设计用于监视系统状态，而不是用于同步控制。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getWaitQueueLength</span><span class="hljs-params">(ConditionObject condition)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!owns(condition))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Not owner&quot;</span>);<br>        <span class="hljs-keyword">return</span> condition.getWaitQueueLength();<br>    &#125;<br><br>    <span class="hljs-comment">// 返回一个集合，该集合包含可能正在等待与此同步器关联的给定条件的那些线程。</span><br>    <span class="hljs-comment">// 因为实际的线程集在构造这个结果时可能会动态变化，</span><br>    <span class="hljs-comment">// 所以返回的集合只是一个最佳估计。返回集合的元素没有特定的顺序。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> Collection&lt;Thread&gt; <span class="hljs-title function_">getWaitingThreads</span><span class="hljs-params">(ConditionObject condition)</span> &#123;<br>        <span class="hljs-keyword">if</span> (!owns(condition))<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Not owner&quot;</span>);<br>        <span class="hljs-keyword">return</span> condition.getWaitingThreads();<br>    &#125; <br><br>    <span class="hljs-comment">// AbstractQueuedSynchronizer的条件实现，作为锁实现的基础。</span><br>    <span class="hljs-comment">// 这个类的方法文档描述的是机制，而不是从锁和条件用户的角度来看的行为规范。</span><br>    <span class="hljs-comment">// 该类的导出版本通常需要附带描述依赖于相关AbstractQueuedSynchronizer的条件语义的文档。</span><br>    <span class="hljs-comment">// 该类是可序列化的，但所有字段都是transient 的，因此反序列化的condition没有等待者。</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConditionObject</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Condition</span>, java.io.Serializable &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">serialVersionUID</span> <span class="hljs-operator">=</span> <span class="hljs-number">1173984872572414699L</span>;<br>         <span class="hljs-comment">/** First node of condition queue. */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ConditionNode firstWaiter;<br>        <span class="hljs-comment">/** Last node of condition queue. */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">transient</span> ConditionNode lastWaiter; <br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Creates a new &#123;<span class="hljs-doctag">@code</span> ConditionObject&#125; instance.</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-title function_">ConditionObject</span><span class="hljs-params">()</span> &#123; &#125; <br><br>        <span class="hljs-comment">// Signalling methods </span><br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * Removes and transfers one or all waiters to sync queue. </span><br><span class="hljs-comment">         * 移除一个或所有等待者并将其转移到同步队列</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doSignal</span><span class="hljs-params">(ConditionNode first, <span class="hljs-type">boolean</span> all)</span> &#123;<br>            <span class="hljs-keyword">while</span> (first != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-type">ConditionNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> first.nextWaiter;<br>                <span class="hljs-keyword">if</span> ((firstWaiter = next) == <span class="hljs-literal">null</span>)<br>                    lastWaiter = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">if</span> ((first.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>) &#123;<br>                    enqueue(first);<br>                    <span class="hljs-keyword">if</span> (!all)<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                first = next;<br>            &#125;<br>        &#125; <br><br>        <span class="hljs-comment">// 将等待时间最长的线程(如果存在)从该条件的等待队列移至拥有锁的等待队列</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signal</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">ConditionNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>            <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>            <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>                doSignal(first, <span class="hljs-literal">false</span>);<br>        &#125; <br><br>        <span class="hljs-comment">// 将所有线程从该条件的等待队列移至所属锁的等待队列。</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">signalAll</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">ConditionNode</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstWaiter;<br>            <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>            <span class="hljs-keyword">if</span> (first != <span class="hljs-literal">null</span>)<br>                doSignal(first, <span class="hljs-literal">true</span>);<br>        &#125; <br><br>        <span class="hljs-comment">// 等待 方法</span><br><br>        <span class="hljs-comment">// 添加一个节点到条件列表并释放锁</span><br>        <span class="hljs-comment">// 持有锁才能await（在等待之后重新acquire savedState）</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-title function_">enableWait</span><span class="hljs-params">(ConditionNode node)</span> &#123;<br>            <span class="hljs-keyword">if</span> (isHeldExclusively()) &#123;<br>                node.waiter = Thread.currentThread();<br>                node.setStatusRelaxed(COND | WAITING);<br>                <span class="hljs-type">ConditionNode</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> lastWaiter;<br>                <span class="hljs-keyword">if</span> (last == <span class="hljs-literal">null</span>)<br>                    firstWaiter = node;<br>                <span class="hljs-keyword">else</span><br>                    last.nextWaiter = node;<br>                lastWaiter = node;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> getState();<br>                <span class="hljs-keyword">if</span> (release(savedState))<br>                    <span class="hljs-keyword">return</span> savedState;<br>            &#125;<br>            node.status = CANCELLED; <span class="hljs-comment">// lock not held or inconsistent</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>        &#125; <br><br>        <span class="hljs-comment">// 如果最初放在条件队列中的节点现在准备好重新获取同步队列，则返回true。</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canReacquire</span><span class="hljs-params">(ConditionNode node)</span> &#123;<br>            <span class="hljs-comment">// check links, not status to avoid enqueue race</span><br>            Node p; <span class="hljs-comment">// traverse unless known to be bidirectionally linked</span><br>            <span class="hljs-keyword">return</span> node != <span class="hljs-literal">null</span> &amp;&amp; (p = node.prev) != <span class="hljs-literal">null</span> &amp;&amp;<br>                (p.next == node || isEnqueued(node));<br>        &#125; <br><br>        <span class="hljs-comment">// 从条件队列中取消给定节点和其他非等待节点的链接，除非已经取消链接。</span><br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">unlinkCancelledWaiters</span><span class="hljs-params">(ConditionNode node)</span> &#123;<br>            <span class="hljs-keyword">if</span> (node == <span class="hljs-literal">null</span> || node.nextWaiter != <span class="hljs-literal">null</span> || node == lastWaiter) &#123;<br>                <span class="hljs-comment">// trail 保存w的前驱</span><br>                <span class="hljs-type">ConditionNode</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> firstWaiter, trail = <span class="hljs-literal">null</span>;<br>                <span class="hljs-keyword">while</span> (w != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-type">ConditionNode</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> w.nextWaiter;<br>                    <span class="hljs-keyword">if</span> ((w.status &amp; COND) == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// 将w从队列中清除</span><br>                        w.nextWaiter = <span class="hljs-literal">null</span>;<br>                        <span class="hljs-keyword">if</span> (trail == <span class="hljs-literal">null</span>)<br>                            firstWaiter = next;<br>                        <span class="hljs-keyword">else</span><br>                            trail.nextWaiter = next;<br>                        <span class="hljs-comment">// w未队列中最后一个节点</span><br>                        <span class="hljs-keyword">if</span> (next == <span class="hljs-literal">null</span>)<br>                            lastWaiter = trail;<br>                    &#125; <span class="hljs-keyword">else</span><br>                        trail = w;<br>                    w = next;<br>                &#125;<br>            &#125;<br>        &#125; <br><br>        <span class="hljs-comment">// 实现非打断条件等待</span><br>        <span class="hljs-comment">// 1.保存getState返回的锁定状态。</span><br>        <span class="hljs-comment">// 2.以保存的状态作为参数调用release，如果失败则抛出 IllegalMonitorStateException</span><br>        <span class="hljs-comment">// 3.阻塞，直到被唤醒</span><br>        <span class="hljs-comment">// 4.通过调用acquire的专用版本重新获取，并将保存的状态作为参数。</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">awaitUninterruptibly</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br>            LockSupport.setCurrentBlocker(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// for back-compatibility</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, rejected = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br>                <span class="hljs-keyword">if</span> (Thread.interrupted())<br>                    interrupted = <span class="hljs-literal">true</span>;<br>                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((node.status &amp; COND) != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">if</span> (rejected)<br>                            node.block();<br>                        <span class="hljs-keyword">else</span><br>                            ForkJoinPool.managedBlock(node);<br>                    &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>                        rejected = <span class="hljs-literal">true</span>;<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>                        interrupted = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span><br>                    Thread.onSpinWait();    <span class="hljs-comment">// awoke while enqueuing</span><br>            &#125;<br>            LockSupport.setCurrentBlocker(<span class="hljs-literal">null</span>);<br>            node.clearStatus();<br>            acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>            <span class="hljs-keyword">if</span> (interrupted)<br>                Thread.currentThread().interrupt();<br>        &#125; <br><br>        <span class="hljs-comment">// 实现可中断条件等待。</span><br>        <span class="hljs-comment">// 1.如果当前线程被中断，抛出InterruptedException。</span><br>        <span class="hljs-comment">// 2.保存getState返回的锁定状态。</span><br>        <span class="hljs-comment">// 3.以保存的状态作为参数调用release，如果失败则抛出IllegalMonitorStateException。</span><br>        <span class="hljs-comment">// 4.阻塞，直到被唤醒或被中断。</span><br>        <span class="hljs-comment">// 5.通过调用acquire的专用版本重新获取，并将保存的状态作为参数。</span><br>        <span class="hljs-comment">// 6.如果在步骤4中被阻塞而中断，抛出InterruptedException</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">await</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>            <span class="hljs-keyword">if</span> (Thread.interrupted())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            <span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br>            LockSupport.setCurrentBlocker(<span class="hljs-built_in">this</span>); <span class="hljs-comment">// for back-compatibility</span><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">interrupted</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, cancelled = <span class="hljs-literal">false</span>, rejected = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br>                <span class="hljs-keyword">if</span> (interrupted |= Thread.interrupted()) &#123;<br>                    <span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br>                        <span class="hljs-keyword">break</span>;              <span class="hljs-comment">// else interrupted after signal</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((node.status &amp; COND) != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">if</span> (rejected)<br>                            node.block();<br>                        <span class="hljs-keyword">else</span><br>                            ForkJoinPool.managedBlock(node);<br>                    &#125; <span class="hljs-keyword">catch</span> (RejectedExecutionException ex) &#123;<br>                        rejected = <span class="hljs-literal">true</span>;<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException ie) &#123;<br>                        interrupted = <span class="hljs-literal">true</span>;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span><br>                    Thread.onSpinWait();    <span class="hljs-comment">// awoke while enqueuing</span><br>            &#125;<br>            LockSupport.setCurrentBlocker(<span class="hljs-literal">null</span>);<br>            node.clearStatus();<br>            acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>            <span class="hljs-keyword">if</span> (interrupted) &#123;<br>                <span class="hljs-keyword">if</span> (cancelled) &#123;<br>                    unlinkCancelledWaiters(node);<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>                &#125;<br>                Thread.currentThread().interrupt();<br>            &#125;<br>        &#125; <br><br>        <span class="hljs-comment">// 带超时的await</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">awaitNanos</span><span class="hljs-params">(<span class="hljs-type">long</span> nanosTimeout)</span><br>                <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>            <span class="hljs-keyword">if</span> (Thread.interrupted())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            <span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> (nanosTimeout &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0L</span> : nanosTimeout;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, interrupted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br>                <span class="hljs-keyword">if</span> ((interrupted |= Thread.interrupted()) ||<br>                    (nanos = deadline - System.nanoTime()) &lt;= <span class="hljs-number">0L</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br>                        <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span><br>                    LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>            &#125;<br>            node.clearStatus();<br>            acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>            <span class="hljs-keyword">if</span> (cancelled) &#123;<br>                unlinkCancelledWaiters(node);<br>                <span class="hljs-keyword">if</span> (interrupted)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interrupted)<br>                Thread.currentThread().interrupt();<br>            <span class="hljs-type">long</span> <span class="hljs-variable">remaining</span> <span class="hljs-operator">=</span> deadline - System.nanoTime(); <span class="hljs-comment">// avoid overflow</span><br>            <span class="hljs-keyword">return</span> (remaining &lt;= nanosTimeout) ? remaining : Long.MIN_VALUE;<br>        &#125; <br><br>        <span class="hljs-comment">// 绝对定时的条件等待</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">awaitUntil</span><span class="hljs-params">(Date deadline)</span><br>                <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">abstime</span> <span class="hljs-operator">=</span> deadline.getTime();<br>            <span class="hljs-keyword">if</span> (Thread.interrupted())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            <span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, interrupted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br>                <span class="hljs-keyword">if</span> ((interrupted |= Thread.interrupted()) ||<br>                    System.currentTimeMillis() &gt;= abstime) &#123;<br>                    <span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br>                        <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span><br>                    LockSupport.parkUntil(<span class="hljs-built_in">this</span>, abstime);<br>            &#125;<br>            node.clearStatus();<br>            acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>            <span class="hljs-keyword">if</span> (cancelled) &#123;<br>                unlinkCancelledWaiters(node);<br>                <span class="hljs-keyword">if</span> (interrupted)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interrupted)<br>                Thread.currentThread().interrupt();<br>            <span class="hljs-keyword">return</span> !cancelled;<br>        &#125; <br><br>        <span class="hljs-comment">// 自定义时间格式的await</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">await</span><span class="hljs-params">(<span class="hljs-type">long</span> time, TimeUnit unit)</span><br>                <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanosTimeout</span> <span class="hljs-operator">=</span> unit.toNanos(time);<br>            <span class="hljs-keyword">if</span> (Thread.interrupted())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            <span class="hljs-type">ConditionNode</span> <span class="hljs-variable">node</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConditionNode</span>();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">savedState</span> <span class="hljs-operator">=</span> enableWait(node);<br>            <span class="hljs-type">long</span> <span class="hljs-variable">nanos</span> <span class="hljs-operator">=</span> (nanosTimeout &lt; <span class="hljs-number">0L</span>) ? <span class="hljs-number">0L</span> : nanosTimeout;<br>            <span class="hljs-type">long</span> <span class="hljs-variable">deadline</span> <span class="hljs-operator">=</span> System.nanoTime() + nanos;<br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">cancelled</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>, interrupted = <span class="hljs-literal">false</span>;<br>            <span class="hljs-keyword">while</span> (!canReacquire(node)) &#123;<br>                <span class="hljs-keyword">if</span> ((interrupted |= Thread.interrupted()) ||<br>                    (nanos = deadline - System.nanoTime()) &lt;= <span class="hljs-number">0L</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (cancelled = (node.getAndUnsetStatus(COND) &amp; COND) != <span class="hljs-number">0</span>)<br>                        <span class="hljs-keyword">break</span>;<br>                &#125; <span class="hljs-keyword">else</span><br>                    LockSupport.parkNanos(<span class="hljs-built_in">this</span>, nanos);<br>            &#125;<br>            node.clearStatus();<br>            acquire(node, savedState, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-number">0L</span>);<br>            <span class="hljs-keyword">if</span> (cancelled) &#123;<br>                unlinkCancelledWaiters(node);<br>                <span class="hljs-keyword">if</span> (interrupted)<br>                    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">InterruptedException</span>();<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (interrupted)<br>                Thread.currentThread().interrupt();<br>            <span class="hljs-keyword">return</span> !cancelled;<br>        &#125; <br><br>        <span class="hljs-comment">// 可观察性支持</span><br><br>        <span class="hljs-comment">// 如果此条件是由给定的同步对象创建的，则返回true。</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">isOwnedBy</span><span class="hljs-params">(AbstractQueuedSynchronizer sync)</span> &#123;<br>            <span class="hljs-keyword">return</span> sync == AbstractQueuedSynchronizer.<span class="hljs-built_in">this</span>;<br>        &#125; <br><br>        <span class="hljs-comment">// 查询是否有任何线程正在等待该条件</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasWaiters</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">ConditionNode</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> firstWaiter; w != <span class="hljs-literal">null</span>; w = w.nextWaiter) &#123;<br>                <span class="hljs-keyword">if</span> ((w.status &amp; COND) != <span class="hljs-number">0</span>)<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125; <br><br>        <span class="hljs-comment">// 返回在这个condition下等待的线程数的估计值</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getWaitQueueLength</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>            <span class="hljs-type">int</span> <span class="hljs-variable">n</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">ConditionNode</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> firstWaiter; w != <span class="hljs-literal">null</span>; w = w.nextWaiter) &#123;<br>                <span class="hljs-keyword">if</span> ((w.status &amp; COND) != <span class="hljs-number">0</span>)<br>                    ++n;<br>            &#125;<br>            <span class="hljs-keyword">return</span> n;<br>        &#125; <br><br>        <span class="hljs-comment">// 返回一个集合，其中包含可能正在等待此条件的那些线程。</span><br>        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Collection&lt;Thread&gt; <span class="hljs-title function_">getWaitingThreads</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">if</span> (!isHeldExclusively())<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalMonitorStateException</span>();<br>            ArrayList&lt;Thread&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">ConditionNode</span> <span class="hljs-variable">w</span> <span class="hljs-operator">=</span> firstWaiter; w != <span class="hljs-literal">null</span>; w = w.nextWaiter) &#123;<br>                <span class="hljs-keyword">if</span> ((w.status &amp; COND) != <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> w.waiter;<br>                    <span class="hljs-keyword">if</span> (t != <span class="hljs-literal">null</span>)<br>                        list.add(t);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> list;<br>        &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>acquire(Node node, int arg, boolean shared, boolean interruptible, boolean timed, long time)</code>：node对应的线程获取锁，即排他地修改AbstractQueuedSynchronizer 的状态（state）。只有CLH队列中的第一个节点或者还未入队的节点有竞争锁的资格，否则在队列中阻塞</p>
<p><code>tryAcquire(int arg) 和 tryRelease(int arg)</code> 本质上都是修改AbstractQueuedSynchronizer 的状态</p>
<p><code>acquire(int arg)</code>：在上面的acquire之前先 tryAcquire 一次</p>
<p><code>release(int arg)</code>：tryRelease 成功后唤醒队列中阻塞的节点</p>
<p><code>await()</code>：一直阻塞，直到其他线程调用signal或signalAll后对应的节点进入CLH队列，最后执行acquire逻辑获取锁（还要和其他节点竞争，哭）。</p>
<blockquote>
<p>注意：</p>
<ol>
<li><p>await时会先判断当前线程是否持有锁，emmm，这很符合逻辑</p>
</li>
<li><p>其他await方法逻辑类似</p>
</li>
</ol>
</blockquote>
<p><code>signal() 和 signalAll()</code>：将第一个（所有）符合条件的ConditionNode插入到CLH队列尾部</p>
<p>根据上面的分析知继承了AbstractQueuedSynchronizer的类通过不同的修改state的策略来达到不同的效果</p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" class="category-chain-item">源码解析</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/JUC/">#JUC</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
<!--    <div class="license-title">-->
<!--      <div>AQS源码解析.md</div>-->
<!--      <div>https://xiaohuanxiong3.github.io/2023/05/30/AQS源码解析/</div>-->
<!--    </div>-->
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Handsome Young</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年5月30日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            MIT
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/06/03/ReentrantLock%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/" title="ReentrantLock源码解析">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">ReentrantLock源码解析</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/05/20/3-cache/" title="3-cache.md">
                        <span class="hidden-mobile">3-cache.md</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> <div>小浣熊的博客 ｜ 记录有趣的收获</div> 
    </div>
  
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.2/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
